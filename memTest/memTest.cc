#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <fcntl.h>
#include <ctype.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <stdint.h>
  
#define FATAL do { fprintf(stderr, "Error at line %d, file %s (%d) [%s]\n", \
  __LINE__, __FILE__, errno, strerror(errno)); exit(1); } while(0)
 
#define INCPTR(p,n) p = (void*) ( ((unsigned long) p) + ((unsigned long) n) )
#define ADDPTR(p,n)     (void*) ( ((unsigned long) p) + ((unsigned long) n) )


void
usage(const char* cmd)
{
    fprintf(stderr, "Usage: %s [options] b:dd.f bar offset (data | -L num)\n", cmd);
    fprintf(stderr, "       %s [options] physAddr (data | -L num)\n", cmd);
    fprintf(stderr, "\n");
    fprintf(stderr, "    physAddr  Physical address (in hex) to target. Must be 64-bytes aligned.\n\n");
    fprintf(stderr, "    b:dd.f    Bus, device (in hex) and function number to target.\n");
    fprintf(stderr, "    bar       BAR number [0-5] to target.\n");
    fprintf(stderr, "    offset    Offset (in hex) within BAR region to target.\n");
    fprintf(stderr, "    physAddr  Physical address (in hex) to target. Must be 64-bytes aligned.\n\n");
    fprintf(stderr, "    data      Data value (in hex) to use. Number of hex digit determines size of transaction.\n\n");
    fprintf(stderr, "\n");
    fprintf(stderr, "Options:\n");
    fprintf(stderr, "    -r        Perform a memory read\n");
    fprintf(stderr, "    -R        Perform a memory read + compare\n");
    fprintf(stderr, "    -w        Perform a memory write\n");
    fprintf(stderr, "    -L num    Use 'num' randomly-generated bytes (max 4096)\n");
    fprintf(stderr, "\n");
    
    exit(1);
}


unsigned int
x2d(char c)
{
    if ('0' <= c && c <= '9') return c - '0';
    if ('a' <= c && c <= 'f') return c - 'a' + 10;
    if ('A' <= c && c <= 'F') return c - 'A' + 10;
    return 0;
}


bool gRD  = true;
bool gWR  = true;
bool gCH  = true;


template<typename T, unsigned int N>
bool
rwTest(void *addr, uint64_t *bytes)
{
    bool pass = true;
    
    T wdat = *((T*) bytes);
    T rdat = 0;
    
    if (gWR) {
        *((volatile T*) addr) = wdat;
    }

    if (gRD) {
        rdat = *((volatile T*) addr);
    }

    if (gCH) {
        pass = (rdat == wdat);
        printf("memtest %s: act: 0x%0*lx   exp: 0x%0*lx.\n", (pass) ? "PASS" : "FAIL", N, (uint64_t) rdat, N, (uint64_t) wdat);
    }

    return pass;
}

int
main(int argc, char **argv)
{
    if (argc < 2 || argc > 6) usage(argv[0]);

    unsigned int optind = 1;

    if (argv[1][0] == '-') {
        switch (argv[1][1]) {
        case 'r':
            gCH = false;
        case 'R':
            gWR  = false;
            break;
            
        case 'w':
        case 'W':
            gRD  = false;
            gCH  = false;
            break;

        default:
            usage(argv[0]);
        }
        optind = 2;
    }

    unsigned int busNum;
    unsigned int devNum;
    unsigned int fnNum;
    uint64_t physAddr = 0;
    
    if (sscanf(argv[optind], "%d:%x.%d", &busNum, &devNum, &fnNum) != 3) {
        if (sscanf(argv[optind], "%lx", &physAddr) != 1) {
            if (argc > 2) {
                fprintf(stderr, "Invalid PCI device \"%s\" specified.\n", argv[optind]);
            } else {
                fprintf(stderr, "Invalid physical address \"%s\" specified.\n", argv[optind]);
            }
            usage(argv[0]);
        }
    }

    char devFile[2048];
    
    if (!physAddr) {
        unsigned int barNum = atoi(argv[optind+1]);
        if (barNum > 5) {
            fprintf(stderr, "Invalid BAR number \"%s\" specified.\n", argv[optind+1]);
            usage(argv[0]);
        }
    
        sprintf(devFile, "/sys/bus/pci/devices/0000:%02x:%02x.%d/resource%d", busNum, devNum, fnNum, barNum);
        if (access(devFile, F_OK)) {
            fprintf(stderr, "Invalid PCI device \"%s\" or BAR number \"%s\" specified: \"%s\" does not exist.\n", argv[optind], argv[optind+1], devFile);
            usage(argv[0]);
        }
        
        optind += 2;
        
        physAddr = strtoul(argv[optind++], 0, 0);
    } else {
        strcpy(devFile, "/dev/mem");

        optind += 1;
    }

    if (optind == argc) {
        fprintf(stderr, "No data value specified.\n");
        usage(argv[0]);
    }
        
    uint64_t wdata = 0;
    unsigned int nBytes = 0;
        
    const char* q = argv[optind++];

    // -l num or 0xvalue???

    if (*q == '-' && *(q+1) == 'L') {
        nBytes = atoi(q+3);
        if (nBytes > 4096) nBytes = 4096;
    } else {
        // Skip leading "0x"
        if (*q == '0' && *(q+1) == 'x') q += 2;
        
        nBytes = strlen(q) / 2;
        if (nBytes == 0 || nBytes > 8) {
            fprintf(stderr, "Invalid data \"%s\" specified.\n", argv[optind-1]);
            usage(argv[0]);
        }
        
        // Translate the HEX string into a byte stream
        uint8_t *p = (uint8_t*) &wdata + nBytes - 1;
        while (*q != '\0') {
            *p = 0;
            if (!isxdigit(*q) || !isxdigit(*(q+1))) {
                fprintf(stderr, "Invalid hex digit \"%c%c\" in data \"%s\" specified.\n", *q, *(q+1), argv[optind-1]);
                usage(argv[0]);
            }
            
            *p = (x2d(*q) << 4) + x2d(*(q+1));
            p--;
            q += 2;
        }
    }
    if (nBytes == 0) {
        usage(argv[0]);
    }
    

    int fd;
    if ((fd = open(devFile, O_RDWR | O_SYNC)) == -1) FATAL;
    
    // Map one page
    unsigned int mapped_size    = 4096UL;
    unsigned int page_size      = mapped_size;
    unsigned int offset_in_page = (unsigned)(physAddr & (uint64_t) (page_size - 1));
    if (offset_in_page + nBytes > page_size) {
        /* This access spans pages.
         * Must map two pages to make it possible
         */
        mapped_size *= 2;
    }
    
    void *map_base = mmap(NULL, mapped_size,
                          PROT_READ | PROT_WRITE,
                          MAP_SHARED, fd,
                          physAddr & ~(off_t)(page_size - 1));
    if (map_base == NULL || map_base == (void *) -1) FATAL;
    
    void* virt_addr = ADDPTR(map_base, offset_in_page);

    bool pass = true;
    
    if (nBytes <= 1)      pass = rwTest< uint8_t,  2>(virt_addr, &wdata);
    else if (nBytes <= 2) pass = rwTest<uint16_t,  4>(virt_addr, &wdata);
    else if (nBytes <= 4) pass = rwTest<uint32_t,  8>(virt_addr, &wdata);
    else if (nBytes <= 8) pass = rwTest<uint64_t, 16>(virt_addr, &wdata);
    else {
        char wdat[4096];
        char rdat[4096];

        for (unsigned int i = 0; i < nBytes; i++) wdat[i] = i;
        
        if (gRD) memcpy(rdat, virt_addr, nBytes);
        if (gWR) memcpy(virt_addr, wdat, nBytes);

        if (gCH) {
            for (unsigned int i = 0; i < nBytes; i++) {
                if (wdat[i] != rdat[i]) {
                    pass = false;
                    printf("memtest FAIL: Byte 0x%02x is 0x%02x but expecting 0x%02x.\n", i, rdat[i], wdat[i]);
                }
            }
        }
    }

    if (munmap(map_base, mapped_size) == -1) FATAL;
    close(fd);

    return (pass) ? 0 : -1;
}
